# 1. Рефакторинг src/check_env.py
Code:
```python
import sys
import cv2
import os
from typing import Tuple

def check_opencv_version() -> Tuple[bool, str]:
    """Проверка версии OpenCV"""
    if not cv2.__version__.startswith('4.'):
        return False, f"OpenCV version mismatch. Expected 4.x, got {cv2.__version__}"
    return True, ""

def check_haar_cascade() -> Tuple[bool, str]:
    """Проверка наличия каскада Хаара"""
    cascade_path = cv2.data.haarcascades + 'haarcascade_frontalface_default.xml'
    
    if os.path.exists(cascade_path):
        return True, cascade_path
    
    # Пытаемся исправить путь для Windows
    windows_path = r'C:\path\to\opencv\data\haarcascades\'
    if os.path.exists(windows_path + 'haarcascade_frontalface_default.xml'):
        # Возвращаем путь, но не изменяем глобальное состояние
        return True, windows_path + 'haarcascade_frontalface_default.xml'
    
    return False, f"Haar cascade file not found at {cascade_path}"

def check_environment() -> Tuple[bool, str, str]:
    """
    Основная функция проверки окружения.
    Возвращает: (успех, сообщение, путь_к_каскаду)
    """
    # Проверяем версию OpenCV
    success, message = check_opencv_version()
    if not success:
        return False, message, ""
    
    # Проверяем наличие каскада Хаара
    success, cascade_path_or_message = check_haar_cascade()
    if not success:
        return False, cascade_path_or_message, ""
    
    return True, "Environment check passed.", cascade_path_or_message

def main() -> int:
    """
    Точка входа для запуска как скрипта.
    Возвращает код возврата для sys.exit()
    """
    success, message, _ = check_environment()
    
    if success:
        print(message)
        return 0
    else:
        print(message, file=sys.stderr)
        return 1

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
```

# 2. Обновленные тесты

Code:
```python
import unittest
from unittest.mock import patch, MagicMock, mock_open
import sys
import os

# Патчим sys.exit чтобы он не завершал выполнение тестов
@patch('sys.exit')
class TestCheckEnv(unittest.TestCase):
    
    def setUp(self):
        """Настройка перед каждым тестом"""
        # Импортируем модуль после настройки моков
        import importlib
        self.check_env = importlib.import_module('src.check_env')
    
    def tearDown(self):
        """Очистка после каждого теста"""
        # Удаляем модуль из кэша для чистой перезагрузки
        if 'src.check_env' in sys.modules:
            del sys.modules['src.check_env']
    
    @patch('cv2.__version__', '4.8.0')
    @patch('os.path.exists')
    def test_check_environment_success(self, mock_exists, mock_exit):
        """Тест успешной проверки окружения"""
        mock_exists.return_value = True
        
        success, message, cascade_path = self.check_env.check_environment()
        
        self.assertTrue(success)
        self.assertEqual(message, "Environment check passed.")
        self.assertIn('haarcascade_frontalface_default.xml', cascade_path)
    
    @patch('cv2.__version__', '3.4.0')
    def test_check_opencv_version_fail(self, mock_exit):
        """Тест неправильной версии OpenCV"""
        success, message, _ = self.check_env.check_environment()
        
        self.assertFalse(success)
        self.assertIn("OpenCV version mismatch", message)
    
    @patch('cv2.__version__', '4.8.0')
    @patch('os.path.exists')
    def test_check_haar_cascade_not_found(self, mock_exists, mock_exit):
        """Тест отсутствия каскада Хаара"""
        mock_exists.return_value = False
        
        success, message, _ = self.check_env.check_environment()
        
        self.assertFalse(success)
        self.assertIn("Haar cascade file not found", message)
    
    @patch('cv2.__version__', '4.8.0')
    @patch('os.path.exists')
    def test_check_haar_cascade_windows_path(self, mock_exists, mock_exit):
        """Тест поиска каскада по Windows пути"""
        mock_exists.side_effect = lambda x: 'C:\\path\\to' in x
        
        success, message, cascade_path = self.check_env.check_environment()
        
        self.assertTrue(success)
        self.assertIn("C:\\path\\to", cascade_path)
    
    def test_check_opencv_version_function(self, mock_exit):
        """Тест отдельной функции проверки версии OpenCV"""
        with patch('cv2.__version__', '4.8.0'):
            success, message = self.check_env.check_opencv_version()
            self.assertTrue(success)
            self.assertEqual(message, "")
        
        with patch('cv2.__version__', '3.4.0'):
            success, message = self.check_env.check_opencv_version()
            self.assertFalse(success)
            self.assertIn("OpenCV version mismatch", message)
    
    @patch('os.path.exists')
    def test_check_haar_cascade_function(self, mock_exists, mock_exit):
        """Тест отдельной функции проверки каскада"""
        mock_exists.return_value = True
        
        success, cascade_path = self.check_env.check_haar_cascade()
        
        self.assertTrue(success)
        self.assertIn('haarcascade_frontalface_default.xml', cascade_path)
    
    @patch('sys.stderr')
    @patch('sys.stdout')
    def test_main_function_success(self, mock_stdout, mock_stderr, mock_exit):
        """Тест функции main при успехе"""
        with patch.object(self.check_env, 'check_environment') as mock_check:
            mock_check.return_value = (True, "Success", "/path/to/cascade")
            
            result = self.check_env.main()
            
            self.assertEqual(result, 0)
            mock_check.assert_called_once()
    
    @patch('sys.stderr')
    @patch('sys.stdout')
    def test_main_function_failure(self, mock_stdout, mock_stderr, mock_exit):
        """Тест функции main при ошибке"""
        with patch.object(self.check_env, 'check_environment') as mock_check:
            mock_check.return_value = (False, "Error message", "")
            
            result = self.check_env.main()
            
            self.assertEqual(result, 1)
            mock_check.assert_called_once()


# Тест для проверки работы как скрипта
class TestCheckEnvAsScript(unittest.TestCase):
    
    def test_script_execution(self):
        """Тест выполнения скрипта напрямую"""
        import subprocess
        import sys
        
        # Запускаем скрипт в отдельном процессе
        result = subprocess.run(
            [sys.executable, '-c', """
import sys
sys.path.insert(0, 'src')
from check_env import main
sys.exit(main())
"""],
            capture_output=True,
            text=True
        )
        
        # Проверяем, что скрипт запускается без ошибок импорта
        self.assertIn('Environment check passed', result.stdout + result.stderr)


if __name__ == '__main__':
    unittest.main()
```

# 3. Рефакторинг тестов

3. Дополнительные улучшения
   Для полного решения проблемы с глобальным состоянием OpenCV, можно добавить контекстный менеджер:
```python
# src/check_env.py (дополнение)

import contextlib

@contextlib.contextmanager
def temporary_haarcascade_path(new_path: str):
    """Временное изменение пути к каскадам Хаара"""
    import cv2
    original_path = cv2.data.haarcascades
    
    try:
        cv2.data.haarcascades = new_path
        yield
    finally:
        cv2.data.haarcascades = original_path


def check_environment_with_context(haar_path: str = None) -> Tuple[bool, str, str]:
    """
    Проверка окружения с возможностью временного изменения пути.
    """
    import cv2
    
    if haar_path:
        with temporary_haarcascade_path(haar_path):
            return check_environment()
    else:
        return check_environment()
```

# Основные преимущества этого подхода:

1. Разделение логики: Функции теперь чисто логические, без побочных эффектов

2. Возврат значений вместо sys.exit: Теперь можно тестировать функции без завершения процесса

3. Сохраняется обратная совместимость: Скрипт можно запускать напрямую

4. Контролируемые зависимости: Легко мокать cv2.__version__ и os.path.exists

5. Изоляция тестов: Каждый тест получает чистый импорт модуля

Это решение позволяет полностью тестировать логику проверки окружения без побочных эффектов и завершения процесса выполнения тестов.